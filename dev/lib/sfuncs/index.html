<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Stochastic Functions · Scruff.jl</title><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Scruff.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Getting Started</a></li><li><a class="tocitem" href="../../tutorial/tutorial/">Tutorial</a></li><li><a class="tocitem" href="../../tutorial/examples/">Examples</a></li><li><span class="tocitem">Library</span><ul><li><a class="tocitem" href="../core/">Core</a></li><li class="is-active"><a class="tocitem" href>Stochastic Functions</a></li><li><a class="tocitem" href="../operators/">Operators</a></li><li><a class="tocitem" href="../models/">Models</a></li><li><a class="tocitem" href="../algorithms/">Algorithms</a></li><li><a class="tocitem" href="../utilities/">Utilities</a></li><li><a class="tocitem" href="../rtutils/">Runtime Utilities</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Library</a></li><li class="is-active"><a href>Stochastic Functions</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Stochastic Functions</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/charles-river-analytics/Scruff.jl/blob/develop/docs/src/lib/sfuncs.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="scruff_sfuncs"><a class="docs-heading-anchor" href="#scruff_sfuncs">Scruff.SFuncs</a><a id="scruff_sfuncs-1"></a><a class="docs-heading-anchor-permalink" href="#scruff_sfuncs" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="Scruff.SFuncs.Apply" href="#Scruff.SFuncs.Apply"><code>Scruff.SFuncs.Apply</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Apply{J, O} &lt;: SFunc{Tuple{SFunc{J, O}, J}, O}</code></pre><p>Apply represents an sfunc that takes two groups of arguments.  The first group is a single argument, which is an sfunc to apply to the second group of arguments.</p><p><strong>Additional supported operators</strong></p><ul><li><code>support</code></li><li><code>support_quality</code></li><li><code>sample</code></li><li><code>logcpdf</code></li><li><code>compute_pi</code></li><li><code>send_lambda</code></li></ul><p><strong>Type parameters</strong></p><ul><li><code>J</code>: the input type of the <em>sfunc</em> that may be applied; that <em>sfunc</em> is the input type of the <code>Apply</code></li><li><code>O</code>: the output type of the <em>sfunc</em> that may be applied, which is also the output type of the <code>Apply</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/charles-river-analytics/Scruff.jl/blob/a4a5895ef8849b4df4f473c31845d12d7ca0da29/src/sfuncs/compound/apply.jl#L3-L20">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Scruff.SFuncs.Cat" href="#Scruff.SFuncs.Cat"><code>Scruff.SFuncs.Cat</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">mutable struct Cat{O} &lt;: Dist{O, Vector{Real}}</code></pre><p><code>Cat</code> defines an sfunc that represents a set of categorical output values that are not conditioned on any input.  Its parameters are always of type <code>Vector{Real}</code>, which is the probability of each output value.</p><p><strong>Supported operations</strong></p><ul><li><code>support</code></li><li><code>support_quality</code></li><li><code>sample</code></li><li><code>cpdf</code></li><li><code>bounded_probs</code></li><li><code>compute_pi</code></li><li><code>f_expectation</code></li></ul><p><strong>Type parameters</strong></p><ul><li><code>O</code>: the output type of the <code>Cat</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/charles-river-analytics/Scruff.jl/blob/a4a5895ef8849b4df4f473c31845d12d7ca0da29/src/sfuncs/dist/cat.jl#L6-L24">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Scruff.SFuncs.Chain" href="#Scruff.SFuncs.Chain"><code>Scruff.SFuncs.Chain</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct Chain{I, J, K, O} &lt;: Conditional{I, J, K, O, Nothing, Q, SFunc{J, O, Nothing}}</code></pre><p>A <code>Conditional</code> that chains its input <code>I</code> through a given function that returns an  <code>SFunc{J,O}</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/charles-river-analytics/Scruff.jl/blob/a4a5895ef8849b4df4f473c31845d12d7ca0da29/src/sfuncs/compound/chain.jl#L3-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Scruff.SFuncs.Conditional" href="#Scruff.SFuncs.Conditional"><code>Scruff.SFuncs.Conditional</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type Conditional{I &lt;: Tuple, J &lt;: Tuple, K &lt;: Tuple, O, S &lt;: SFunc{J, O}} &lt;: SFunc{K, O}</code></pre><p><code>Conditional</code> <em>sfuncs</em> represent the generation of an sfunc depending on the values of parents.  An subtype of <code>Conditional</code> must provide a <code>gensf</code> method that takes an <code>I</code> and returns an  <code>SFunc{J,O}</code> (<strong>important</strong> the generated SFunc must not appear outside the Conditional.  It should not be a parent).</p><p><strong>Additional supported operators</strong></p><ul><li><code>support</code></li><li><code>support_quality</code></li><li><code>sample</code></li><li><code>logcpdf</code></li><li><code>make_factors</code></li><li><code>compute_pi</code></li><li><code>send_lambda</code></li></ul><p><strong>Type parameters</strong></p><ul><li><code>I</code>: the type of data used to generate the <code>Conditional</code>&#39;s <em>sfunc</em></li><li><code>J</code>: a tuple that represents the input types (the <code>I</code>) of the <code>Conditional</code>&#39;s generated <em>sfunc</em></li><li><code>K</code>: the input types of the <code>Conditional</code>; this is a tuple of types constructed from <code>I</code>, </li></ul><p>and <code>J</code> using <code>extend_tuple_types</code></p><ul><li><code>O</code>: the output type(s) of both the <code>Conditional</code> and the <code>Conditional</code>&#39;s generated <em>sfunc</em></li><li><code>S</code>: the type of the <code>Conditional</code>&#39;s generated <em>sfunc</em></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/charles-river-analytics/Scruff.jl/blob/a4a5895ef8849b4df4f473c31845d12d7ca0da29/src/sfuncs/conddist/conditional.jl#L45-L70">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Scruff.SFuncs.Constant" href="#Scruff.SFuncs.Constant"><code>Scruff.SFuncs.Constant</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">mutable struct Constant{O} &lt;: Dist{O,Nothing}</code></pre><p><code>Constant</code> represents an sfunc that always produces the same value.  It has no inputs and no parameters.</p><p><strong>Additional supported operators</strong></p><ul><li><code>support</code></li><li><code>support_quality</code></li><li><code>sample</code></li><li><code>logcpdf</code></li><li><code>bounded_probs</code></li><li><code>compute_pi</code></li></ul><p><strong>Type parameters</strong></p><ul><li><code>O</code>: the output type(s) of the <code>Constant</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/charles-river-analytics/Scruff.jl/blob/a4a5895ef8849b4df4f473c31845d12d7ca0da29/src/sfuncs/dist/constant.jl#L4-L20">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Scruff.SFuncs.Det" href="#Scruff.SFuncs.Det"><code>Scruff.SFuncs.Det</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type Det{I, O} &lt;: SFunc{I, O}</code></pre><p><code>Det</code> defines an <em>sfunc</em> that represents a deterministic function <code>I -&gt; O</code>.  When a <code>Det</code> is subtyped, a function <code>apply(d::Det, i::I)::O</code> or <code>apply(d::Det, i::I...)::O</code> must also be implemented.  It has no parameters.</p><p><strong>Additional supported operators</strong></p><ul><li><code>support</code></li><li><code>support_quality</code></li><li><code>sample</code></li><li><code>logcpdf</code></li><li><code>bounded_probs</code></li><li><code>make_factors</code></li><li><code>compute_pi</code></li><li><code>send_lambda</code></li></ul><p><strong>Type parameters</strong></p><ul><li><code>I</code>: the input type(s) of the <code>Det</code></li><li><code>O</code>: the output type(s) of the <code>Det</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/charles-river-analytics/Scruff.jl/blob/a4a5895ef8849b4df4f473c31845d12d7ca0da29/src/sfuncs/conddist/det.jl#L8-L26">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Scruff.SFuncs.Expander" href="#Scruff.SFuncs.Expander"><code>Scruff.SFuncs.Expander</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">mutable struct Expander{I,O} &lt;: SFunc{I,O}</code></pre><p>An Expander represents a model defined by a function that returns a network. For a given value of an input, the conditional probability distribution is provided by the network produced by the function on that input.</p><p>For each such network, the expander manages a runtime to reason about it. Expanders are lazy and do not evaluate the function until they have to.</p><p>As a result, there is state associated with Expanders. This is analysis state rather than world state, i.e., it is the state of Scruff&#39;s reasoning about the Expander. In keeping with Scruff design, Expanders are immutable and all state associated with reasoning is stored in the runtime that contains the expander. To support this, a runtime has three fields of global state:</p><ul><li><code>:subnets</code>: the expansions of all Expanders managed by the runtime</li><li><code>:subruntimes</code>: all the subruntimes recursively managed by this runtime through Expanders, keyed by the networks</li><li><code>:depth</code>: the depth to which Expanders in this runtime should be expanded</li></ul><p><strong>Type parameters</strong></p><ul><li><code>I</code>: the input type(s) of the <code>Expander</code></li><li><code>O</code>: the output type(s) of the <code>Expander</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/charles-river-analytics/Scruff.jl/blob/a4a5895ef8849b4df4f473c31845d12d7ca0da29/src/sfuncs/compound/expander.jl#L5-L31">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Scruff.SFuncs.ExplicitDet" href="#Scruff.SFuncs.ExplicitDet"><code>Scruff.SFuncs.ExplicitDet</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct ExplicitDet{I, O} &lt;: Det{I, O}</code></pre><p><code>ExplicitDet</code> is a <code>Det</code> that contains a field <code>f::Function</code>.  It also has an <code>apply</code> method that simply delegates to the <code>ExplicitDet</code>&#39;s function:</p><pre><code class="nohighlight hljs">    apply(d::ExplicitDet, i...) = d.f(i...)</code></pre><pre><code class="nohighlight hljs">julia&gt; d = ExplicitDet{Tuple{Vararg{Real}},Real}(sum)
ExplicitDet{Tuple{Vararg{Real, N} where N}, Real}(sum)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/charles-river-analytics/Scruff.jl/blob/a4a5895ef8849b4df4f473c31845d12d7ca0da29/src/sfuncs/conddist/det.jl#L29-L40">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Scruff.SFuncs.Extend" href="#Scruff.SFuncs.Extend"><code>Scruff.SFuncs.Extend</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct Extend{I&lt;:Tuple{Any},J,O} &lt;: SFunc{J,O}</code></pre><p><code>Extend</code> defines an sfunc that extend the input of another sfunc. Useful for defining Separable SFuncs.</p><p><strong>Additional supported operators</strong></p><ul><li><code>support</code></li><li><code>support_quality</code></li><li><code>sample</code></li><li><code>logcpdf</code></li><li><code>bounded_probs</code></li><li><code>make_factors</code></li><li><code>compute_pi</code></li><li><code>send_lambda</code></li></ul><p><strong>Type parameters</strong></p><ul><li><code>I</code>: the input type(s) of the extended <em>sfunc</em>; it must be a tuple of length 1</li><li><code>J</code>: the input type(s) of the <code>Extend</code></li><li><code>O</code>: the output type(s) of both the <code>Extend</code> and the extended <em>sfunc</em> </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/charles-river-analytics/Scruff.jl/blob/a4a5895ef8849b4df4f473c31845d12d7ca0da29/src/sfuncs/util/extend.jl#L3-L23">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Scruff.SFuncs.FunctionalScore" href="#Scruff.SFuncs.FunctionalScore"><code>Scruff.SFuncs.FunctionalScore</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct FunctionalScore{I} &lt;: Score{I}</code></pre><p>A score defined by a function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/charles-river-analytics/Scruff.jl/blob/a4a5895ef8849b4df4f473c31845d12d7ca0da29/src/sfuncs/score/functionalscore.jl#L3-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Scruff.SFuncs.Generate" href="#Scruff.SFuncs.Generate"><code>Scruff.SFuncs.Generate</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Generate{O} &lt;: SFunc{Tuple{Dist{O}}, O}</code></pre><p>Generate a value from its <code>Dist</code> argument.</p><p>This helps in higher-order programming. A typical pattern will be to create an sfunc that produces a <code>Dist</code>, and then generate many observations from the <code>Dist</code> using <code>Generate</code>.</p><p><strong>Additional supported operators</strong></p><ul><li><code>support</code></li><li><code>support_quality</code></li><li><code>sample</code></li><li><code>logcpdf</code></li><li><code>compute_pi</code></li><li><code>send_lambda</code></li><li><code>make_factors</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/charles-river-analytics/Scruff.jl/blob/a4a5895ef8849b4df4f473c31845d12d7ca0da29/src/sfuncs/compound/generate.jl#L5-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Scruff.SFuncs.HardScore" href="#Scruff.SFuncs.HardScore"><code>Scruff.SFuncs.HardScore</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">HardScore{I} &lt;: Score{I}</code></pre><p>A fixed score.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/charles-river-analytics/Scruff.jl/blob/a4a5895ef8849b4df4f473c31845d12d7ca0da29/src/sfuncs/score/hardscore.jl#L3-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Scruff.SFuncs.Invertible" href="#Scruff.SFuncs.Invertible"><code>Scruff.SFuncs.Invertible</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct Invertible{I,O} &lt;: SFunc{Tuple{I},O}</code></pre><p>An invertible sfunc, with both a <code>forward</code> and a <code>inverse</code> function provided.</p><p><strong>Additional supported operators</strong></p><ul><li><code>support</code></li><li><code>support_quality</code></li><li><code>sample</code></li><li><code>logcpdf</code></li><li><code>bounded_probs</code></li><li><code>make_factors</code></li><li><code>compute_pi</code></li><li><code>send_lambda</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/charles-river-analytics/Scruff.jl/blob/a4a5895ef8849b4df4f473c31845d12d7ca0da29/src/sfuncs/conddist/invertible.jl#L4-L18">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Scruff.SFuncs.LinearGaussian" href="#Scruff.SFuncs.LinearGaussian"><code>Scruff.SFuncs.LinearGaussian</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">mutable struct LinearGaussian{I &lt;: Tuple{Vararg{Float64}}} &lt;: 
    Conditional{I, Tuple{}, I, Float64, Normal}</code></pre><p><code>LinearGaussian</code> defines an sfunc whose mean is a linear function of its parents.  A  <code>LinearGaussian</code>&#39;s output type is a <code>Float</code>, its parameter type is  <code>Tuple{I, Float64, Float64}</code>, and it&#39;s contained <em>sfunc</em> is a <code>Normal</code> mean <code>0.0</code>.</p><p><strong>Type parameters</strong></p><ul><li><code>I</code>: the input type(s) of the <code>LinearGaussian</code></li></ul><p>See also: <a href="#Scruff.SFuncs.Conditional"><code>Conditional</code></a>, <a href="#Scruff.SFuncs.Normal"><code>Normal</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/charles-river-analytics/Scruff.jl/blob/a4a5895ef8849b4df4f473c31845d12d7ca0da29/src/sfuncs/conddist/lineargaussian.jl#L3-L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Scruff.SFuncs.LogScore" href="#Scruff.SFuncs.LogScore"><code>Scruff.SFuncs.LogScore</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct LogScore{I} &lt;: Score{I}</code></pre><p>A Log score.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/charles-river-analytics/Scruff.jl/blob/a4a5895ef8849b4df4f473c31845d12d7ca0da29/src/sfuncs/score/logscore.jl#L3-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Scruff.SFuncs.Mixture" href="#Scruff.SFuncs.Mixture"><code>Scruff.SFuncs.Mixture</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">mutable struct Mixture{I,O} &lt;: SFunc{I,O}</code></pre><p><code>Mixture</code> defines an <em>sfunc</em> representing mixtures of other <em>sfuncs</em>.  It contains a  vector of <em>sfuncs</em> and a vector of probabilities that those <em>sfuncs</em> are selected,  which indices are keys associating the two.  The output type of a <code>Mixture</code> is defined by the output type of its internal components.  The parameters of a <code>Mixture</code> are its probabilities followed by parameters of all its internal components, in order. </p><p><strong>Additional supported operators</strong></p><ul><li><code>support</code></li><li><code>support_quality</code></li><li><code>sample</code></li><li><code>cpdf</code></li><li><code>expectation</code></li><li><code>compute_pi</code></li><li><code>send_lambda</code></li></ul><p><strong>Type parameters</strong></p><ul><li><code>I</code>: the input type(s) of the <code>Mixture</code></li><li><code>O</code>: the shared output type(s) of its internal components and the output type(s) of the <code>Mixture</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/charles-river-analytics/Scruff.jl/blob/a4a5895ef8849b4df4f473c31845d12d7ca0da29/src/sfuncs/compound/mixture.jl#L3-L24">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Scruff.SFuncs.NetworkSFunc" href="#Scruff.SFuncs.NetworkSFunc"><code>Scruff.SFuncs.NetworkSFunc</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct NetworkSFunc{I,O} &lt;: SFunc{I,O}</code></pre><p>An sfunc that combines multiple sfuncs in a network structure.</p><p><strong>Arguments</strong></p><pre><code class="nohighlight hljs">input_placeholders A vector of placeholders indicating the types of network inputs. The type parameter `I` is computed from these.
sfuncs The sfuncs to combine.
parents A `Dict` that maps sfuncs to their parent sfuncs. Note that this parallels networks, 
     except that we are mapping sfuncs to lists of sfuncs directly rather than variables to vectors of variables.
output A vector of output sfuncs, determining the `O` type parameter.</code></pre><p><strong>Additional supported operators</strong></p><ul><li><code>sample</code></li><li><code>sample_logcpdf</code></li><li><code>logcpdf</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/charles-river-analytics/Scruff.jl/blob/a4a5895ef8849b4df4f473c31845d12d7ca0da29/src/sfuncs/compound/network.jl#L12-L28">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Scruff.SFuncs.Normal" href="#Scruff.SFuncs.Normal"><code>Scruff.SFuncs.Normal</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">mutable struct Normal &lt;: Dist{Float64}</code></pre><p><code>Normal</code> defines an <em>sfunc</em> representing unconditional Gaussian distributions.  Its has no input, its output type is <code>Float64</code>, and its parameters are <code>(mean,standard deviation)</code>.</p><p><strong>Additional supported operators</strong></p><ul><li><code>support</code></li><li><code>support_quality</code></li><li><code>sample</code></li><li><code>logcpdf</code></li><li><code>bounded_probs</code></li><li><code>compute_pi</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/charles-river-analytics/Scruff.jl/blob/a4a5895ef8849b4df4f473c31845d12d7ca0da29/src/sfuncs/dist/normal.jl#L5-L18">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Scruff.SFuncs.NormalScore" href="#Scruff.SFuncs.NormalScore"><code>Scruff.SFuncs.NormalScore</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct NormalScore &lt;: Score{Float64}</code></pre><p>A score defined by a normal density given the mean and sd of the score.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/charles-river-analytics/Scruff.jl/blob/a4a5895ef8849b4df4f473c31845d12d7ca0da29/src/sfuncs/score/normalscore.jl#L3-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Scruff.SFuncs.Parzen" href="#Scruff.SFuncs.Parzen"><code>Scruff.SFuncs.Parzen</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct Parzen &lt;: Score{Float64}</code></pre><p>A parzen score.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/charles-river-analytics/Scruff.jl/blob/a4a5895ef8849b4df4f473c31845d12d7ca0da29/src/sfuncs/score/parzen.jl#L3-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Scruff.SFuncs.SepCPTs" href="#Scruff.SFuncs.SepCPTs"><code>Scruff.SFuncs.SepCPTs</code></a> — <span class="docstring-category">Type</span></header><section><div><p>SepCPTs = Array{Dict{I, Array{Float64, 1}} where I}</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/charles-river-analytics/Scruff.jl/blob/a4a5895ef8849b4df4f473c31845d12d7ca0da29/src/sfuncs/conddist/separable.jl#L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Scruff.SFuncs.Serial" href="#Scruff.SFuncs.Serial"><code>Scruff.SFuncs.Serial</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct Serial{I,O} &lt;: SFunc{I,O}</code></pre><p>A sequence of sfuncs in series.</p><p>Although this could be implemented as a special case of NetworkSFunc, the serial composition allows an easier and more efficient implementation of operations. All but the first sfunc in the sequence will have a single input; the output of each sfunc feeds into the input of the next sfunc.</p><p>To work properly, most of the operations on <code>Serial</code> need the support of the intermediate sfuncs, given an input range. Rather than compute this each time, and to avoid having the non-support operations take a size argument, support is memoized, and must be called before other operations like logcpdf are called. The <code>support_memo</code> is a dictionary whose keys are tuples of parent ranges and whose values are the support computed for those parent ranges, along with the target size for which they were computed. Storing the target size enables refinement algorithms that increase the size and improve  the support.</p><p><strong>Additional supported operators</strong></p><ul><li><code>support</code></li><li><code>support_quality</code></li><li><code>sample</code></li><li><code>cpdf</code></li><li><code>bounded_probs</code></li><li><code>make_factors</code></li><li><code>compute_pi</code></li><li><code>send_lambda</code></li></ul><p><strong>Type parameters</strong></p><ul><li>I the input type of the first sfunc</li><li>O the output type of the last sfunc</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/charles-river-analytics/Scruff.jl/blob/a4a5895ef8849b4df4f473c31845d12d7ca0da29/src/sfuncs/compound/serial.jl#L5-L37">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Scruff.SFuncs.Switch" href="#Scruff.SFuncs.Switch"><code>Scruff.SFuncs.Switch</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type Switch{N, I, K, O} &lt;: Det{K, O}</code></pre><p><code>Switch</code> defines an sfunc that represents choosing between multiple incoming (parent) Sfuncs  based on a test.  A subtype of <code>Switch</code> must provide a <code>choose</code> function that takes the switch  and an <code>i</code> and returns an integer between <code>1</code> and <code>N</code>.  This is an index into a &#39;parent array&#39;.</p><p><code>K</code> must be a flat tuple type consisting of <code>I</code> and <code>N</code> occurrences of <code>O</code>:  for example, if I is <code>Int</code></p><pre><code class="nohighlight hljs">    K = extend_tuple_type(Tuple{Int}, NTuple{N, O})</code></pre><p>If the subtype&#39;d sfunc is not in the Scruff.SFuncs module, the system must  <code>import Scruff.SFuncs: choose</code>.</p><p><strong>Additional supported operators</strong></p><ul><li><code>support</code></li><li><code>support_quality</code></li><li><code>compute_pi</code></li><li><code>send_lambda</code></li></ul><p><strong>Type parameters</strong></p><ul><li><code>N</code>: the count of <em>sfuncs</em> from which to choose</li><li><code>I</code>: the type of the second argument of the <code>choose</code> function defined for the <code>Switch</code></li><li><code>K</code>: the input type of the <code>Switch</code>; see above</li><li><code>O</code>: the output type of the <code>Switch</code> </li></ul><p>See also:  <a href="#Scruff.SFuncs.choose"><code>choose</code></a>, <a href="#Scruff.SFuncs.extend_tuple_type-Tuple{Any, Any}"><code>extend_tuple_type</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/charles-river-analytics/Scruff.jl/blob/a4a5895ef8849b4df4f473c31845d12d7ca0da29/src/sfuncs/conddist/switch.jl#L7-L37">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Scruff.SFuncs.Table" href="#Scruff.SFuncs.Table"><code>Scruff.SFuncs.Table</code></a> — <span class="docstring-category">Type</span></header><section><div><p>mutable struct Table{NumInputs, I &lt;: NTuple{NumInputs, Any}, J, K, O, S &lt;: SFunc{J,O}} &lt;: Conditional{I, J, K, O, S}</p><p><code>Table</code> defines a <code>Conditional</code> whose function is given by a multi-dimensional table of type  <code>Array{Q, NumInputs}</code>, where <code>Q</code> is the output type of the internal <em>sfunc</em> and <code>NumInputs</code> is the count of incoming parent values.</p><p>See also:  <a href="#Scruff.SFuncs.Conditional"><code>Conditional</code></a>, <a href="#Scruff.SFuncs.DiscreteCPT-Union{Tuple{O}, Tuple{I}, Tuple{Vector{O}, Dict{I, Vector{Float64}}}} where {I&lt;:Tuple, O}"><code>DiscreteCPT</code></a>, <a href="#Scruff.SFuncs.CLG-Tuple{Dict}"><code>CLG</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/charles-river-analytics/Scruff.jl/blob/a4a5895ef8849b4df4f473c31845d12d7ca0da29/src/sfuncs/conddist/table.jl#L4-L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Scruff.SFuncs.CLG-Tuple{Dict}" href="#Scruff.SFuncs.CLG-Tuple{Dict}"><code>Scruff.SFuncs.CLG</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">CLG(paramdict::Dict)</code></pre><p>Constructs an*sfunc representing a Conditional linear Gaussian.  These sfuncs may have  both discrete and continuous parents.  For each combination of discrete parents, there is  a <code>LinearGaussian</code> that depends on the continuous parents.</p><p><code>CLG</code>s are implemented as a <code>Table</code> with a <code>LinearGaussian</code>.</p><p>The <code>paramdict</code> parameter defines the discrete and continuous parents, and the linear  gaussean values where the length of a key is the count of the discrete inputs, the  length of the tuple in a value is the count of continuous inputs, and the rest of the values are used to build the parameters for <code>CLG</code> itself.  For example,</p><pre><code class="nohighlight hljs">    Dict((:x,1) =&gt; ((-1.0, 1.0, 2.0), 3.0, 1.0), 
         (:x,2) =&gt; ((-2.0, 4.0, 2.0), 3.0, 1.0),
         (:x,3) =&gt; ((-3.0, 2.0, 2.0), 3.0, 1.0), 
         (:y,1) =&gt; ((-4.0, 5.0, 2.0), 3.0, 1.0),
         (:y,2) =&gt; ((-5.0, 3.0, 2.0), 3.0, 1.0), 
         (:y,3) =&gt; ((-6.0, 6.0, 2.0), 3.0, 1.0))</code></pre><pre><code class="nohighlight hljs">- the keys define two(2) discrete parents, with values `[:x,:y]` and `[1,2,3]`
- in the values, the first tuple defines three(3) continuous parents for each
  underlying `LinearGausian`, with values `-1.0:-6.0`, `1.0:6.0`, and `2.0`
- the values `3.0` and `1.0` are mean/stddev of the underlying `LinearGaussian`</code></pre><p>See also: <a href="#Scruff.SFuncs.Table"><code>Table</code></a>, <a href="#Scruff.SFuncs.LinearGaussian"><code>LinearGaussian</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/charles-river-analytics/Scruff.jl/blob/a4a5895ef8849b4df4f473c31845d12d7ca0da29/src/sfuncs/conddist/CLG.jl#L4-L33">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Scruff.SFuncs.DiscreteCPT-Union{Tuple{O}, Tuple{I}, Tuple{Vector{O}, Dict{I, Vector{Float64}}}} where {I&lt;:Tuple, O}" href="#Scruff.SFuncs.DiscreteCPT-Union{Tuple{O}, Tuple{I}, Tuple{Vector{O}, Dict{I, Vector{Float64}}}} where {I&lt;:Tuple, O}"><code>Scruff.SFuncs.DiscreteCPT</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function DiscreteCPT(range::Vector{O}, paramdict::Dict{I, Vector{Float64}}) where {I &lt;: Tuple, O}</code></pre><p>Constructs an sfunc that represents a Discrete Conditional Probability table.</p><p><code>DiscreteCPT</code>s are implemented as a <code>Table</code> with a <code>Cat</code>.</p><p>The <code>range</code> parameter defines all the possible outputs of the <code>DiscreteCPT</code>.  The <code>paramdict</code>  parameter defines the input(s) and the actual CPT.  For example, </p><pre><code class="nohighlight hljs">    range = [1, 2]
    paramdict = Dict((1,1) =&gt; [0.3, 0.7], (1,2) =&gt; [0.6, 0.4], (2,1) =&gt;[0.4, 0.6],
    (2,2) =&gt; [0.7, 0.3], (3,1) =&gt; [0.5, 0.5], (3,2) =&gt; [0.8, 0.2])</code></pre><p>can create a <code>DiscreteCPT</code> which has two(2) inputs (the length of the key) and, given each input as defined by the key, selects either <code>1</code> or <code>2</code> (the range) with the given probability.  So, if the input is <code>(2,1)</code>, <code>1</code> is selected with probability <code>0.4</code> and <code>2</code> is selected with probability <code>0.6</code>.</p><p>See also: <a href="#Scruff.SFuncs.Table"><code>Table</code></a>, <a href="#Scruff.SFuncs.Cat"><code>Cat</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/charles-river-analytics/Scruff.jl/blob/a4a5895ef8849b4df4f473c31845d12d7ca0da29/src/sfuncs/conddist/discretecpt.jl#L4-L26">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Scruff.SFuncs.Flip-Tuple{Any}" href="#Scruff.SFuncs.Flip-Tuple{Any}"><code>Scruff.SFuncs.Flip</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Flip(p)</code></pre><p>Constructs a very simple <em>sfunc</em> corresponding to a Bernoulli distribution,  represented by a <code>Cat</code>.  The output is <code>true</code> with probability <code>p</code>, and <code>false</code> with probability <code>1-p</code>.</p><p>See also: <a href="#Scruff.SFuncs.Cat"><code>Cat</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/charles-river-analytics/Scruff.jl/blob/a4a5895ef8849b4df4f473c31845d12d7ca0da29/src/sfuncs/dist/flip.jl#L3-L11">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Scruff.SFuncs.Separable-Union{Tuple{O}, Tuple{Vector{O}, Vector{Float64}, Array{Dict{I, Vector{Float64}} where I}}} where O" href="#Scruff.SFuncs.Separable-Union{Tuple{O}, Tuple{Vector{O}, Vector{Float64}, Array{Dict{I, Vector{Float64}} where I}}} where O"><code>Scruff.SFuncs.Separable</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function Separable(range::Vector{O}, probabilities :: Vector{Float64}, compparams :: SepCPTs) where O</code></pre><p>Constructs an sfunc representing separable models, defined by additive decompositon of a conditional probability distribution into separate distributions depending on each of the parents.</p><p><code>Separable</code>s are implemented as a <code>Mixture</code> of <code>Extend</code> sfuncs that extend <code>DiscreteCPT</code>s.</p><p>To construct a <code>Separable</code>, this method is passed the <code>range</code> of output values, the <code>probabilities</code> of each of the underlying <code>DiscreteCPT</code> (which are the internal sfuncs of the <code>Mixture</code>), and the parameters for each of the <code>DiscreteCPT</code>s.  For example, </p><pre><code class="nohighlight hljs">alphas = [0.2, 0.3, 0.5]
cpd1 = Dict((1,) =&gt; [0.1, 0.9], (2,) =&gt; [0.2, 0.8])
cpd2 = Dict((1,) =&gt; [0.3, 0.7], (2,) =&gt; [0.4, 0.6], (3,) =&gt; [0.5, 0.5])
cpd3 = Dict((1,) =&gt; [0.6, 0.4], (2,) =&gt; [0.7, 0.3])
cpds :: Array{Dict{I,Array{Float64,1}} where I,1} = [cpd1, cpd2, cpd3]
s = Separable([1, 2], alphas, cpds)</code></pre><p>See also:  <a href="#Scruff.SFuncs.Mixture"><code>Mixture</code></a>, <a href="#Scruff.SFuncs.Extend"><code>Extend</code></a>, <a href="#Scruff.SFuncs.DiscreteCPT-Union{Tuple{O}, Tuple{I}, Tuple{Vector{O}, Dict{I, Vector{Float64}}}} where {I&lt;:Tuple, O}"><code>DiscreteCPT</code></a>, <a href="#Scruff.SFuncs.Table"><code>Table</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/charles-river-analytics/Scruff.jl/blob/a4a5895ef8849b4df4f473c31845d12d7ca0da29/src/sfuncs/conddist/separable.jl#L9-L31">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Scruff.SFuncs.SoftScore-Union{Tuple{Dict{I, Float64}}, Tuple{I}} where I" href="#Scruff.SFuncs.SoftScore-Union{Tuple{Dict{I, Float64}}, Tuple{I}} where I"><code>Scruff.SFuncs.SoftScore</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">SoftScore(scores::Dict{I,Float64})</code></pre><p>Return a <code>LogScore</code> of the keys and log values in <code>score</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/charles-river-analytics/Scruff.jl/blob/a4a5895ef8849b4df4f473c31845d12d7ca0da29/src/sfuncs/score/softscore.jl#L13-L17">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Scruff.SFuncs.SoftScore-Union{Tuple{I}, Tuple{Vector{I}, Vector{Float64}}} where I" href="#Scruff.SFuncs.SoftScore-Union{Tuple{I}, Tuple{Vector{I}, Vector{Float64}}} where I"><code>Scruff.SFuncs.SoftScore</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">SoftScore(vs::Vector{I}, ss::Vector{Float64})</code></pre><p>Return a <code>LogScore</code> of the log values in <code>ss</code> vector for  the associated keys in <code>vs</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/charles-river-analytics/Scruff.jl/blob/a4a5895ef8849b4df4f473c31845d12d7ca0da29/src/sfuncs/score/softscore.jl#L3-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Scruff.SFuncs.choose" href="#Scruff.SFuncs.choose"><code>Scruff.SFuncs.choose</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>choose</code> interface.  For every subtype of <code>Switch</code>, an implementation of this method must be created, whose first parameter is the subtype, and the second parameter is of type <code>I</code> for the parameter type in <code>Switch</code>.</p><p>For example, the definition of the <code>If</code> <em>sfunc</em> is as follows, where <code>choose</code> returns either index <code>1</code> or index <code>2</code>.</p><pre><code class="nohighlight hljs">struct If{O} &lt;: Switch{2, Bool, Tuple{Bool, O, O}, O} end
choose(::If, b::Bool) = b ? 1 : 2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/charles-river-analytics/Scruff.jl/blob/a4a5895ef8849b4df4f473c31845d12d7ca0da29/src/sfuncs/conddist/switch.jl#L40-L52">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Scruff.SFuncs.dist-Tuple{Any}" href="#Scruff.SFuncs.dist-Tuple{Any}"><code>Scruff.SFuncs.dist</code></a> — <span class="docstring-category">Method</span></header><section><div><p>returns a <code>Distributions.Normal</code> from a <code>Scruff.SFuncs.Normal</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/charles-river-analytics/Scruff.jl/blob/a4a5895ef8849b4df4f473c31845d12d7ca0da29/src/sfuncs/dist/normal.jl#L38">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Scruff.SFuncs.extend_tuple_type-Tuple{Any, Any}" href="#Scruff.SFuncs.extend_tuple_type-Tuple{Any, Any}"><code>Scruff.SFuncs.extend_tuple_type</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">extend_tuple_type(T1, T2)</code></pre><p>Given two types <code>T1</code> and <code>T2</code>, concatenate the types into a single tuple type.  </p><p><strong>Arguments</strong></p><ul><li><code>T1</code>: Any type</li><li><code>T2</code>: A tuple type</li></ul><p><strong>Returns</strong></p><ul><li>If <code>T1</code> is a tuple type, a tuple with the concatenation of the types in <code>T1</code> and <code>T2</code></li><li>If <code>T1</code> is not a tuple type, a tuple with <code>T1</code> prepended to the types in <code>T2</code></li></ul><p><strong>Examples</strong></p><pre><code class="nohighlight hljs">julia&gt; extend_tuple_type(Int64, Tuple{Float64})
Tuple{Int64, Float64}

julia&gt; extend_tuple_type(Tuple{Int64}, Tuple{Float64})
Tuple{Int64, Float64}

julia&gt; extend_tuple_type(Tuple{Vector{Float64}}, Tuple{Symbol,Symbol})     
Tuple{Vector{Float64}, Symbol, Symbol}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/charles-river-analytics/Scruff.jl/blob/a4a5895ef8849b4df4f473c31845d12d7ca0da29/src/sfuncs/conddist/conditional.jl#L11-L36">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Scruff.SFuncs.mean-Tuple{Scruff.SFuncs.Normal}" href="#Scruff.SFuncs.mean-Tuple{Scruff.SFuncs.Normal}"><code>Scruff.SFuncs.mean</code></a> — <span class="docstring-category">Method</span></header><section><div><p>returns the mean of the <code>Normal</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/charles-river-analytics/Scruff.jl/blob/a4a5895ef8849b4df4f473c31845d12d7ca0da29/src/sfuncs/dist/normal.jl#L33">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Scruff.SFuncs.sd-Tuple{Scruff.SFuncs.Normal}" href="#Scruff.SFuncs.sd-Tuple{Scruff.SFuncs.Normal}"><code>Scruff.SFuncs.sd</code></a> — <span class="docstring-category">Method</span></header><section><div><p>returns the standard deviation of the <code>Normal</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/charles-river-analytics/Scruff.jl/blob/a4a5895ef8849b4df4f473c31845d12d7ca0da29/src/sfuncs/dist/normal.jl#L35">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../core/">« Core</a><a class="docs-footer-nextpage" href="../operators/">Operators »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Wednesday 27 March 2024 17:40">Wednesday 27 March 2024</span>. Using Julia version 1.7.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
