<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Algorithms · Scruff.jl</title><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Scruff.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Getting Started</a></li><li><a class="tocitem" href="../../tutorial/tutorial/">Tutorial</a></li><li><a class="tocitem" href="../../tutorial/examples/">Examples</a></li><li><span class="tocitem">Library</span><ul><li><a class="tocitem" href="../core/">Core</a></li><li><a class="tocitem" href="../sfuncs/">Stochastic Functions</a></li><li><a class="tocitem" href="../operators/">Operators</a></li><li><a class="tocitem" href="../models/">Models</a></li><li class="is-active"><a class="tocitem" href>Algorithms</a></li><li><a class="tocitem" href="../utilities/">Utilities</a></li><li><a class="tocitem" href="../rtutils/">Runtime Utilities</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Library</a></li><li class="is-active"><a href>Algorithms</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Algorithms</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/charles-river-analytics/Scruff.jl/blob/develop/docs/src/lib/algorithms.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="scruff_algorithms"><a class="docs-heading-anchor" href="#scruff_algorithms">Scruff.Algorithms</a><a id="scruff_algorithms-1"></a><a class="docs-heading-anchor-permalink" href="#scruff_algorithms" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="Scruff.Algorithms.Queryable" href="#Scruff.Algorithms.Queryable"><code>Scruff.Algorithms.Queryable</code></a> — <span class="docstring-category">Type</span></header><section><div><p>A query target is either a variable instance or a variable. Allowing queries to be defined in terms of instances rather than variables makes it possible to ask queries across multiple instances of a variable at different times. However, in many cases the current instance of the variable(s) is required and then it is easier to use variables.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/charles-river-analytics/Scruff.jl/blob/c3a25875ec56c4d160a78e446e7507615fe40666/src/algorithms/query.jl#L27-L33">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Scruff.Algorithms.Algorithm" href="#Scruff.Algorithms.Algorithm"><code>Scruff.Algorithms.Algorithm</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Algorithm</code></pre><p>The supertype of all algorithms.</p><p>A standard set of queries is defined for algorithms. Any given subtype of <code>Algorithm</code> will implement a subset of these queries.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/charles-river-analytics/Scruff.jl/blob/c3a25875ec56c4d160a78e446e7507615fe40666/src/algorithms/algorithm.jl#L8-L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Scruff.Algorithms.BP" href="#Scruff.Algorithms.BP"><code>Scruff.Algorithms.BP</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type BP &lt;: InstantAlgorithm</code></pre><p>Belief Propagation algorithm</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/charles-river-analytics/Scruff.jl/blob/c3a25875ec56c4d160a78e446e7507615fe40666/src/algorithms/instant/bp.jl#L5-L9">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Scruff.Algorithms.CoherentWindow" href="#Scruff.Algorithms.CoherentWindow"><code>Scruff.Algorithms.CoherentWindow</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct CoherentWindow &lt;: WindowCreator end</code></pre><p>A variant of AsyncWindow that ensures that parent values are never stale for any variable that gets updated in a filter step. In other words, if any parent of a direct parent has been updated more recently than a variable to be updated, the direct parent is added to the variables to be updated. This condition then recurses for the direct parents.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/charles-river-analytics/Scruff.jl/blob/c3a25875ec56c4d160a78e446e7507615fe40666/src/algorithms/filtering/windowcreator.jl#L81-L87">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Scruff.Algorithms.Filter" href="#Scruff.Algorithms.Filter"><code>Scruff.Algorithms.Filter</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type Filter &lt;: Algorithm end</code></pre><p>General type of filtering algorithms.</p><p>Must implement init<em>filter and filter</em>step methods.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/charles-river-analytics/Scruff.jl/blob/c3a25875ec56c4d160a78e446e7507615fe40666/src/algorithms/filtering/filter.jl#L6-L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Scruff.Algorithms.Importance" href="#Scruff.Algorithms.Importance"><code>Scruff.Algorithms.Importance</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Importance &lt;: InstantAlgorithm</code></pre><p>Representation of an importance sampling algorithm.</p><p><strong>arguments</strong></p><ul><li>proposal_function Specifies how the algorithm should make proposals. This is a function</li></ul><p>that takes a runtime and an instance and returns a proposer.  The proposer takes parent values and proposes a value for the instance along with a log score.</p><ul><li>num_particles The number of completed particles to use. This is not necessarily the</li></ul><p>number attempted. If there are rejections, the algorithm will continue to create particles until <code>num_particles</code> have been completed. Warning: With impossible evidence, the process will not terminate.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/charles-river-analytics/Scruff.jl/blob/c3a25875ec56c4d160a78e446e7507615fe40666/src/algorithms/instant/importance.jl#L9-L23">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Scruff.Algorithms.InstantAlgorithm" href="#Scruff.Algorithms.InstantAlgorithm"><code>Scruff.Algorithms.InstantAlgorithm</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">InstantAlgorithm

Algorithm that runs once on an `InstantNetwork`.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/charles-river-analytics/Scruff.jl/blob/c3a25875ec56c4d160a78e446e7507615fe40666/src/algorithms/instant/instantalgorithm.jl#L5-L9">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Scruff.Algorithms.IterativeAlgorithm" href="#Scruff.Algorithms.IterativeAlgorithm"><code>Scruff.Algorithms.IterativeAlgorithm</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type IterativeAlgorithm &lt;: InstantAlgorithm</code></pre><p>Algorithm that runs iteratively on an <code>InstantNetwork</code>.</p><p>The algorithm should support two methods: <code>prepare</code> and <code>refine</code>.</p><p>An IterativeAlgorithm is also trivially an InstantAlgorithm where <code>Infer</code> is implemented by calling <code>prepare</code> and <code>refine</code> once.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/charles-river-analytics/Scruff.jl/blob/c3a25875ec56c4d160a78e446e7507615fe40666/src/algorithms/iterative/iterativealgorithm.jl#L6-L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Scruff.Algorithms.IterativeSampler" href="#Scruff.Algorithms.IterativeSampler"><code>Scruff.Algorithms.IterativeSampler</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct IterativeSampler &lt;: IterativeAlgorithm</code></pre><p>An iterative algorithm that uses a sampler to accumulate more samples on each refinement.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/charles-river-analytics/Scruff.jl/blob/c3a25875ec56c4d160a78e446e7507615fe40666/src/algorithms/iterative/iterativesampler.jl#L4-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Scruff.Algorithms.LazyInference" href="#Scruff.Algorithms.LazyInference"><code>Scruff.Algorithms.LazyInference</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct LazyInference &lt;: IterativeAlgorithm</code></pre><p>An iterative algorithm that expands recursively and increases the ranges of instances on every iteration.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/charles-river-analytics/Scruff.jl/blob/c3a25875ec56c4d160a78e446e7507615fe40666/src/algorithms/iterative/lazyinference.jl#L41-L45">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Scruff.Algorithms.LazyState" href="#Scruff.Algorithms.LazyState"><code>Scruff.Algorithms.LazyState</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">mutable struct LazyState</code></pre><p>Maintains the state of a lazy algorithm</p><p><strong>Fields</strong></p><ul><li><code>previous_algorithm</code>: The last instant algorithm used, if any</li><li><code>evidence</code>: The evidence supplied in <code>prepare</code></li><li><code>interventions</code>: The interventions supplied in <code>prepare</code></li><li><code>placeholder_beliefs</code>: The placeholder beliefs supplied in <code>prepare</code></li><li><code>next_size</code>: The range size to use in the next call to <code>refine</code></li><li><code>next_depth</code>: The depth to use in the next call to <code>refine</code></li><li><code>next_iteration</code>: The number of the next iteration</li><li><code>is_complete</code>: A flag indicating whether the netwowk has been fully expanded</li><li><code>order</code>: The order of nodes used in computations</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/charles-river-analytics/Scruff.jl/blob/c3a25875ec56c4d160a78e446e7507615fe40666/src/algorithms/iterative/lazyinference.jl#L5-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Scruff.Algorithms.LazyState-NTuple{4, Any}" href="#Scruff.Algorithms.LazyState-NTuple{4, Any}"><code>Scruff.Algorithms.LazyState</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">LazyState(ns, nd, ni, ic)</code></pre><p>Intantiate <code>LazyState</code> with <code>next_size</code>, <code>next_depth</code>, <code>next_iterator</code>, and <code>is_complete</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/charles-river-analytics/Scruff.jl/blob/c3a25875ec56c4d160a78e446e7507615fe40666/src/algorithms/iterative/lazyinference.jl#L34-L38">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Scruff.Algorithms.LoopyBP" href="#Scruff.Algorithms.LoopyBP"><code>Scruff.Algorithms.LoopyBP</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">LoopyBP</code></pre><p>An instant algorithm that runs loopy belief propagation.</p><p><strong>Arguments</strong></p><ul><li>default<em>range</em>size: The size to use as default when calling <code>support</code> on a node.</li><li>epsilon: The allowable difference between beliefs on successive iterations </li></ul><p>for termination.</p><ul><li>maxiterations: The maximum number of iterations to run. <code>infer</code> will terminate if </li></ul><p>this number of iterations is reached, even if it has not converged.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/charles-river-analytics/Scruff.jl/blob/c3a25875ec56c4d160a78e446e7507615fe40666/src/algorithms/instant/loopybp.jl#L5-L16">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Scruff.Algorithms.Particles" href="#Scruff.Algorithms.Particles"><code>Scruff.Algorithms.Particles</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct Particles</code></pre><p>A structure of particles containing a vector of <code>Samples</code> and of log_weights. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/charles-river-analytics/Scruff.jl/blob/c3a25875ec56c4d160a78e446e7507615fe40666/src/algorithms/sample_utils.jl#L19-L23">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Scruff.Algorithms.Query" href="#Scruff.Algorithms.Query"><code>Scruff.Algorithms.Query</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type Query end</code></pre><p>General type of query that can be answered after running an algorithm.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/charles-river-analytics/Scruff.jl/blob/c3a25875ec56c4d160a78e446e7507615fe40666/src/algorithms/query.jl#L20-L24">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Scruff.Algorithms.Sample" href="#Scruff.Algorithms.Sample"><code>Scruff.Algorithms.Sample</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Sample = Dict{Symbol, Any}</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/charles-river-analytics/Scruff.jl/blob/c3a25875ec56c4d160a78e446e7507615fe40666/src/algorithms/sample_utils.jl#L16">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Scruff.Algorithms.ThreePassBP" href="#Scruff.Algorithms.ThreePassBP"><code>Scruff.Algorithms.ThreePassBP</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ThreePassBP

An instant algorithm that runs three passes of belief propagation.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/charles-river-analytics/Scruff.jl/blob/c3a25875ec56c4d160a78e446e7507615fe40666/src/algorithms/instant/threepassbp.jl#L7-L11">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Scruff.Algorithms.VE" href="#Scruff.Algorithms.VE"><code>Scruff.Algorithms.VE</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">VE(query_vars::Vector{Variable})</code></pre><p>An instant algorithm that runs variable elimination.</p><p><strong>Arguments</strong></p><ul><li>network</li><li><code>query_vars</code>: The variables to query, which are not eliminated</li><li>depth: A depth of 1 means not to expand expanders, otherwise expands recursively to the given depth</li><li>bounds: If true, return lower and upper bounds factors, otherwise just return a single factor</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/charles-river-analytics/Scruff.jl/blob/c3a25875ec56c4d160a78e446e7507615fe40666/src/algorithms/instant/ve.jl#L9-L19">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Scruff.Algorithms.WindowFilter" href="#Scruff.Algorithms.WindowFilter"><code>Scruff.Algorithms.WindowFilter</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct WindowFilter &lt;: Filter

General construction for a filter based on a flexible windowing scheme.</code></pre><p>#arguments     window<em>creator Defines the method used to create windows     inference</em>algorithm Defines the algorithm to use on a window     postprocess! A postprocessing function, that takes the runtime and does any additional processing needed to carry to the next iteration. Defaults to doing nothing.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/charles-river-analytics/Scruff.jl/blob/c3a25875ec56c4d160a78e446e7507615fe40666/src/algorithms/filtering/windowfilter.jl#L7-L17">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Scruff.Algorithms.AsyncBP" href="#Scruff.Algorithms.AsyncBP"><code>Scruff.Algorithms.AsyncBP</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">AsyncBP(range_size = 10, T = Float64)</code></pre><p>A window filter that uses an asynchronous window with ThreePassBP with the given range size. <code>T</code> represents the time type and must be the same as used in creation of the runtime.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/charles-river-analytics/Scruff.jl/blob/c3a25875ec56c4d160a78e446e7507615fe40666/src/algorithms/filtering/bpfilter.jl#L13-L18">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Scruff.Algorithms.AsyncLoopy" href="#Scruff.Algorithms.AsyncLoopy"><code>Scruff.Algorithms.AsyncLoopy</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">AsyncLoopy(range_size = 10, T = Float64)</code></pre><p>A window filter that uses an asynchronous window with LoopyBP with the given range size. <code>T</code> represents the time type and must be the same as used in creation of the runtime.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/charles-river-analytics/Scruff.jl/blob/c3a25875ec56c4d160a78e446e7507615fe40666/src/algorithms/filtering/loopyfilter.jl#L13-L18">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Scruff.Algorithms.AsyncPF" href="#Scruff.Algorithms.AsyncPF"><code>Scruff.Algorithms.AsyncPF</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">AsyncPF(num_particles::Int, resampling_size::Int = num_particles, T = Float64)</code></pre><p>A particle filter that uses an asynchronous window with the given number of particles and resampling buffer size. <code>T</code> represents the time type and must be the same as used in creation of the runtime.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/charles-river-analytics/Scruff.jl/blob/c3a25875ec56c4d160a78e446e7507615fe40666/src/algorithms/filtering/particlefilter.jl#L24-L29">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Scruff.Algorithms.CoherentBP" href="#Scruff.Algorithms.CoherentBP"><code>Scruff.Algorithms.CoherentBP</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">CoherentBP(range_size = 10, T = Float64)</code></pre><p>A window filter that uses a coherent window with ThreePassBP with the given range size. <code>T</code> represents the time type and must be the same as used in creation of the runtime.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/charles-river-analytics/Scruff.jl/blob/c3a25875ec56c4d160a78e446e7507615fe40666/src/algorithms/filtering/bpfilter.jl#L21-L26">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Scruff.Algorithms.CoherentLoopy" href="#Scruff.Algorithms.CoherentLoopy"><code>Scruff.Algorithms.CoherentLoopy</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">CoherentLoopy(range_size = 10, T = Float64)</code></pre><p>A window filter that uses a coherent window with LoopyBP with the given range size. <code>T</code> represents the time type and must be the same as used in creation of the runtime.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/charles-river-analytics/Scruff.jl/blob/c3a25875ec56c4d160a78e446e7507615fe40666/src/algorithms/filtering/loopyfilter.jl#L21-L26">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Scruff.Algorithms.CoherentPF" href="#Scruff.Algorithms.CoherentPF"><code>Scruff.Algorithms.CoherentPF</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">CoherentPF(num_particles::Int, resampling_size::Int = num_particles, T = Float64)</code></pre><p>A particle filter that uses a coherent window with the given number of particles and resampling buffer size. <code>T</code> represents the time type and must be the same as used in creation of the runtime.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/charles-river-analytics/Scruff.jl/blob/c3a25875ec56c4d160a78e446e7507615fe40666/src/algorithms/filtering/particlefilter.jl#L32-L37">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Scruff.Algorithms.LSFI-Tuple{Any}" href="#Scruff.Algorithms.LSFI-Tuple{Any}"><code>Scruff.Algorithms.LSFI</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function LSFI(query_vars; 
    increment = 10, start_size = increment, max_iterations = 100, start_depth = 1)</code></pre><p>A lazy inference algorithm that uses variable elimination at every step.</p><p><strong>Arguments</strong></p><ul><li><code>query_vars</code>: Variables that can be queried after each <code>refine</code> step</li><li><code>increment</code>: The increment to range size on every iteration</li><li><code>start_size</code>: The starting range size</li><li><code>max_iterations</code>: The maximum number of refinement steps</li><li><code>start_depth</code>: The depth of recursive expansion in the first iteration</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/charles-river-analytics/Scruff.jl/blob/c3a25875ec56c4d160a78e446e7507615fe40666/src/algorithms/iterative/lsfi.jl#L4-L16">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Scruff.Algorithms.SyncBP" href="#Scruff.Algorithms.SyncBP"><code>Scruff.Algorithms.SyncBP</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">SyncBP(range_size = 10)</code></pre><p>A window filter that uses a synchronous window with ThreePassBP with the given range size.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/charles-river-analytics/Scruff.jl/blob/c3a25875ec56c4d160a78e446e7507615fe40666/src/algorithms/filtering/bpfilter.jl#L6-L10">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Scruff.Algorithms.SyncLoopy" href="#Scruff.Algorithms.SyncLoopy"><code>Scruff.Algorithms.SyncLoopy</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">SyncLoopy(range_size = 10)</code></pre><p>A window filter that uses a synchronous window with LoopyBP with the given range size.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/charles-river-analytics/Scruff.jl/blob/c3a25875ec56c4d160a78e446e7507615fe40666/src/algorithms/filtering/loopyfilter.jl#L6-L10">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Scruff.Algorithms.SyncPF" href="#Scruff.Algorithms.SyncPF"><code>Scruff.Algorithms.SyncPF</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">SyncPF(num_particles::Int, resampling_size::Int = num_particles)</code></pre><p>A particle filter that uses a synchronous window with the given number of particles and resampling buffer size.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/charles-river-analytics/Scruff.jl/blob/c3a25875ec56c4d160a78e446e7507615fe40666/src/algorithms/filtering/particlefilter.jl#L17-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Scruff.Algorithms.answer-Tuple{Scruff.Algorithms.Query, Scruff.Algorithms.Algorithm, Runtime, VariableInstance}" href="#Scruff.Algorithms.answer-Tuple{Scruff.Algorithms.Query, Scruff.Algorithms.Algorithm, Runtime, VariableInstance}"><code>Scruff.Algorithms.answer</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">answer(::Query, ::Algorithm, ::Runtime, ::VariableInstance)
answer(::Query, ::Algorithm, ::Runtime, ::Vector{VariableInstance})
answer(::Query, ::Algorithm, ::Runtime, ::Queryable)
answer(::Query, ::Algorithm, ::Runtime, ::Vector{Queryable})

Answer the query.

An implementation of an algorithm should implement an `answer` method for any queries
it can handle. The type hierarchies of `Query` and `Algorithm` will enable
query answering methods to be used wherever appropriate with the right specialization.
The implementations of `answer` are differentiated along two dimensions:
- single or multiple items
- queryable items in general or specifically instances

It is expected that an algorithm will implement one of the first two methods for queries it
can handle. I.e., an algorithm is expected to handle a single instance or a vector of instances.
If it can handle multiple instances, it should implement a second method and a single instance implementation
is derived by default using a singleton vector. An algorithm can still override this default
method if it handles single instances differently from multiple.

Algorithms will generally not implement the latter two methods, which are provide for convenience. 
Default implementations are provided that delegate to the instance-specific methods.

Defining a very high-level default implementation that throws an error enables implementations
to go through sequences of preferences.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/charles-river-analytics/Scruff.jl/blob/c3a25875ec56c4d160a78e446e7507615fe40666/src/algorithms/query.jl#L44-L70">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Scruff.Algorithms.create_window-Tuple{Scruff.Algorithms.SyncWindow, Runtime, Vector{&lt;:Variable}, Int64}" href="#Scruff.Algorithms.create_window-Tuple{Scruff.Algorithms.SyncWindow, Runtime, Vector{&lt;:Variable}, Int64}"><code>Scruff.Algorithms.create_window</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">create_window(::SyncWindow, runtime::Runtime, variables::Vector{&lt;:Variable}, time::Int)::Vector{Instance}</code></pre><p>Creates a window by instantiating all variables at all intermediate time steps from the earliest parent to the given time. The <code>variables</code> argument is ignored.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/charles-river-analytics/Scruff.jl/blob/c3a25875ec56c4d160a78e446e7507615fe40666/src/algorithms/filtering/windowcreator.jl#L22-L27">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Scruff.Algorithms.dynamic_name_and_time" href="#Scruff.Algorithms.dynamic_name_and_time"><code>Scruff.Algorithms.dynamic_name_and_time</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Create a dynamic name and time from an instant node. T is the time type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/charles-river-analytics/Scruff.jl/blob/c3a25875ec56c4d160a78e446e7507615fe40666/src/algorithms/filtering/windowutils.jl#L16-L18">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Scruff.Algorithms.effective_sample_size-Tuple{Vector{Float64}}" href="#Scruff.Algorithms.effective_sample_size-Tuple{Vector{Float64}}"><code>Scruff.Algorithms.effective_sample_size</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">expected_sample_size(log_weights::Vector{Float64})</code></pre><p>Effective sample size</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/charles-river-analytics/Scruff.jl/blob/c3a25875ec56c4d160a78e446e7507615fe40666/src/algorithms/sample_utils.jl#L69-L73">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Scruff.Algorithms.expectation-Tuple{Scruff.Algorithms.Algorithm, Runtime, Union{Variable{I, J, O}, VariableInstance{O}} where {O, I, J}, Function}" href="#Scruff.Algorithms.expectation-Tuple{Scruff.Algorithms.Algorithm, Runtime, Union{Variable{I, J, O}, VariableInstance{O}} where {O, I, J}, Function}"><code>Scruff.Algorithms.expectation</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">expectation(alg::Algorithm, runtime::Runtime, item::Queryable, f::Function)::Float64</code></pre><p>Return the expectation of the function <code>f</code> over the marginal distribution of <code>item</code>.</p><p>The default implementation uses the expectation operation on the SFunc representing the marginal distribution.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/charles-river-analytics/Scruff.jl/blob/c3a25875ec56c4d160a78e446e7507615fe40666/src/algorithms/query.jl#L206-L213">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Scruff.Algorithms.filter_step-Union{Tuple{T}, Tuple{Scruff.Algorithms.Filter, DynamicRuntime{T}, Vector{Variable}, T, Dict{Symbol, Score}}} where T" href="#Scruff.Algorithms.filter_step-Union{Tuple{T}, Tuple{Scruff.Algorithms.Filter, DynamicRuntime{T}, Vector{Variable}, T, Dict{Symbol, Score}}} where T"><code>Scruff.Algorithms.filter_step</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">filter_step(filter::Filter, runtime::Runtime, variables::Vector{Variable}, time::T, evidence::Dict{Symbol, Score})</code></pre><p>Run one step of the filter by instantiating the given variables at the given time and passing in the given evidence.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/charles-river-analytics/Scruff.jl/blob/c3a25875ec56c4d160a78e446e7507615fe40666/src/algorithms/filtering/filter.jl#L22-L26">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Scruff.Algorithms.init_filter!-Tuple{Scruff.Algorithms.Filter, DynamicRuntime}" href="#Scruff.Algorithms.init_filter!-Tuple{Scruff.Algorithms.Filter, DynamicRuntime}"><code>Scruff.Algorithms.init_filter!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">init_filter!(::Filter, ::DynamicRuntime)</code></pre><p>An interface for intializing the filter for a dynamic runtime.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/charles-river-analytics/Scruff.jl/blob/c3a25875ec56c4d160a78e446e7507615fe40666/src/algorithms/filtering/filter.jl#L15-L19">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Scruff.Algorithms.initial_instant_runtime-Tuple{DynamicRuntime}" href="#Scruff.Algorithms.initial_instant_runtime-Tuple{DynamicRuntime}"><code>Scruff.Algorithms.initial_instant_runtime</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Creates an instant runtime for the first time step.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/charles-river-analytics/Scruff.jl/blob/c3a25875ec56c4d160a78e446e7507615fe40666/src/algorithms/filtering/windowutils.jl#L127-L129">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Scruff.Algorithms.instant_name-Tuple{Symbol, Number}" href="#Scruff.Algorithms.instant_name-Tuple{Symbol, Number}"><code>Scruff.Algorithms.instant_name</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Create a name in an instant network corresponding to the given dynamic name and time.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/charles-river-analytics/Scruff.jl/blob/c3a25875ec56c4d160a78e446e7507615fe40666/src/algorithms/filtering/windowutils.jl#L9-L11">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Scruff.Algorithms.instant_node-Tuple{VariableInstance}" href="#Scruff.Algorithms.instant_node-Tuple{VariableInstance}"><code>Scruff.Algorithms.instant_node</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Create an instant node from a dynamic variable instance.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/charles-river-analytics/Scruff.jl/blob/c3a25875ec56c4d160a78e446e7507615fe40666/src/algorithms/filtering/windowutils.jl#L34-L36">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Scruff.Algorithms.instant_node-Union{Tuple{PlaceholderInstance{O}}, Tuple{O}} where O" href="#Scruff.Algorithms.instant_node-Union{Tuple{PlaceholderInstance{O}}, Tuple{O}} where O"><code>Scruff.Algorithms.instant_node</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Create an instant node from a dynamic placeholder instance.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/charles-river-analytics/Scruff.jl/blob/c3a25875ec56c4d160a78e446e7507615fe40666/src/algorithms/filtering/windowutils.jl#L44-L46">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Scruff.Algorithms.instant_runtime_from_instances-Tuple{DynamicRuntime, Vector{Instance}}" href="#Scruff.Algorithms.instant_runtime_from_instances-Tuple{DynamicRuntime, Vector{Instance}}"><code>Scruff.Algorithms.instant_runtime_from_instances</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">instant_runtime_from_instances(runtime::DynamicRuntime, instances::Vector{Instance})</code></pre><p>Create an instant runtime from the given instances in the given dynamic runtime.</p><p>This runtime has an instant network that contains a variable for each instance in <code>insts</code>,  tagged with the time of the instance. The network also contains a placeholder for each instance in <code>placeholder_insts</code>. The function also instantiates the variables in the instant runtime and stores any runtime  values from the dynamic runtime with the corresponding instances in the instant runtime. This function is useful for running instant algorithms on a time window  for dynamic reasoning.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/charles-river-analytics/Scruff.jl/blob/c3a25875ec56c4d160a78e446e7507615fe40666/src/algorithms/filtering/windowutils.jl#L54-L66">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Scruff.Algorithms.joint-Tuple{Scruff.Algorithms.Algorithm, Runtime, Vector{Union{Variable{I, J, O}, VariableInstance{O}} where {O, I, J}}}" href="#Scruff.Algorithms.joint-Tuple{Scruff.Algorithms.Algorithm, Runtime, Vector{Union{Variable{I, J, O}, VariableInstance{O}} where {O, I, J}}}"><code>Scruff.Algorithms.joint</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">joint(alg::Algorithm, run::Runtime, items::Vector{Queryable})::Union{Score{O}, Tuple{Score{O}, Score{O}}}</code></pre><p>Return the joint distribution over <code>items</code>, or lower and upper distributions, depending on the algorithm.</p><p>The returned <code>Score</code> assigns a score for each Vector of values of the items.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/charles-river-analytics/Scruff.jl/blob/c3a25875ec56c4d160a78e446e7507615fe40666/src/algorithms/query.jl#L110-L117">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Scruff.Algorithms.lw_proposal-Tuple{Runtime, VariableInstance}" href="#Scruff.Algorithms.lw_proposal-Tuple{Runtime, VariableInstance}"><code>Scruff.Algorithms.lw_proposal</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">lw_proposal(runtime::Runtime, instance::VariableInstance, parent_values::Tuple)</code></pre><p>Return a proposer and scorer to implement likelihood weighting.</p><p>This proposal scheme is the same as the prior proposal unless a variable has hard evidence. In the case of hard evidence, the proposer sets the value of the variable to the evidence value and scores it by the log conditional probability of the evidence given the parent values.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/charles-river-analytics/Scruff.jl/blob/c3a25875ec56c4d160a78e446e7507615fe40666/src/algorithms/instant/importance.jl#L86-L95">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Scruff.Algorithms.make_custom_proposal-Tuple{Dict{Symbol, SFunc}}" href="#Scruff.Algorithms.make_custom_proposal-Tuple{Dict{Symbol, SFunc}}"><code>Scruff.Algorithms.make_custom_proposal</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">make_custom_proposal(custom_sfs::Dict{Symbol, SFunc})</code></pre><p>Create a proposal function for a custom proposal scheme.</p><p>Returns a proposal function that can be provided to the Importance constructor. Evidence is handled similar to <code>lw</code>, except that the custom proposal is used for soft evidence.</p><p><strong>Arguments</strong></p><ul><li>custom_sfs A dictionary mapping variable names to custom sfuncs used for their proposal.</li></ul><p>Need not be complete; if a variable is not in this dictionary, its standard sfunc will be used.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/charles-river-analytics/Scruff.jl/blob/c3a25875ec56c4d160a78e446e7507615fe40666/src/algorithms/instant/importance.jl#L112-L125">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Scruff.Algorithms.marginal-Tuple{Scruff.Algorithms.Particles, Symbol}" href="#Scruff.Algorithms.marginal-Tuple{Scruff.Algorithms.Particles, Symbol}"><code>Scruff.Algorithms.marginal</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">marginal(parts::Particles, x::Symbol)::Cat</code></pre><p>Returns a Cat representing the marginal distribution over the given symbol according to parts</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/charles-river-analytics/Scruff.jl/blob/c3a25875ec56c4d160a78e446e7507615fe40666/src/algorithms/sample_utils.jl#L48-L52">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Scruff.Algorithms.marginal-Union{Tuple{O}, Tuple{Scruff.Algorithms.Algorithm, Runtime, Union{Variable{I, J, O}, VariableInstance{O}} where {I, J}}} where O" href="#Scruff.Algorithms.marginal-Union{Tuple{O}, Tuple{Scruff.Algorithms.Algorithm, Runtime, Union{Variable{I, J, O}, VariableInstance{O}} where {I, J}}} where O"><code>Scruff.Algorithms.marginal</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">marginal(alg::Algorithm, runtime::Runtime, item::Queryable{O})::Union{Dist{O}, Tuple{Dist{O}, Dist{O}}} where O</code></pre><p>Return the marginal distribution over <code>item</code>, or lower and upper marginals, depending on the algorithm.</p><p>The returned <code>Score</code> assigns a score to each value of <code>item</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/charles-river-analytics/Scruff.jl/blob/c3a25875ec56c4d160a78e446e7507615fe40666/src/algorithms/query.jl#L95-L102">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Scruff.Algorithms.mean-Union{Tuple{O}, Tuple{Scruff.Algorithms.Algorithm, Runtime, Union{Variable{I, J, O}, VariableInstance{O}} where {I, J}}} where O&lt;:Number" href="#Scruff.Algorithms.mean-Union{Tuple{O}, Tuple{Scruff.Algorithms.Algorithm, Runtime, Union{Variable{I, J, O}, VariableInstance{O}} where {I, J}}} where O&lt;:Number"><code>Scruff.Algorithms.mean</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">mean(alg::Algorithm, runtime::Runtime, item::Queryable)</code></pre><p>Return the mean of <code>item</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/charles-river-analytics/Scruff.jl/blob/c3a25875ec56c4d160a78e446e7507615fe40666/src/algorithms/query.jl#L238-L242">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Scruff.Algorithms.normalize_weights-Tuple{Vector{Float64}}" href="#Scruff.Algorithms.normalize_weights-Tuple{Vector{Float64}}"><code>Scruff.Algorithms.normalize_weights</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">normalize_weights(log_weights::Vector{Float64})</code></pre><p>Normalize weights</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/charles-river-analytics/Scruff.jl/blob/c3a25875ec56c4d160a78e446e7507615fe40666/src/algorithms/sample_utils.jl#L79-L83">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Scruff.Algorithms.prepare-Tuple{Scruff.Algorithms.InstantAlgorithm, InstantRuntime, Vector{&lt;:SFunc{Tuple{}}}, Vector{Tuple{Symbol, Score}}, Vector{Tuple{Symbol, SFunc{Tuple{}}}}}" href="#Scruff.Algorithms.prepare-Tuple{Scruff.Algorithms.InstantAlgorithm, InstantRuntime, Vector{&lt;:SFunc{Tuple{}}}, Vector{Tuple{Symbol, Score}}, Vector{Tuple{Symbol, SFunc{Tuple{}}}}}"><code>Scruff.Algorithms.prepare</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">prepare(algorithm::IterativeAlgorithm, runtime::InstantRuntime
    evidence::Dict{Symbol, &lt;:Score}, 
    interventions::Dict{Symbol, &lt;:Dist},
    placeholder_beliefs::Dict{Symbol, &lt;:Dist})</code></pre><p>Prepare the inference algorithm for iteration.</p><p>Stores the algorithm state in <code>runtime</code>. </p><p><strong>Arguments</strong></p><ul><li><code>algorithm</code>: The iterative algorithm to run.</li><li><code>runtime</code>: The runtime in which to run the algorithm.</li><li><code>evidence</code>: The supplied evidence, which defaults to <code>Dict()</code>. </li><li><code>interventions</code>: The supplied interventions, which defaults to <code>Dict()</code>. </li><li><code>placeholder_beliefs</code>: The beliefs associated with the placeholders in the </li></ul><p>network, which default to <code>Dict()</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/charles-river-analytics/Scruff.jl/blob/c3a25875ec56c4d160a78e446e7507615fe40666/src/algorithms/iterative/iterativealgorithm.jl#L18-L35">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Scruff.Algorithms.probability-Tuple{Scruff.Algorithms.Algorithm, Runtime, Vector{Union{Variable{I, J, O}, VariableInstance{O}} where {O, I, J}}, Function}" href="#Scruff.Algorithms.probability-Tuple{Scruff.Algorithms.Algorithm, Runtime, Vector{Union{Variable{I, J, O}, VariableInstance{O}} where {O, I, J}}, Function}"><code>Scruff.Algorithms.probability</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">probability(alg::Algorithm, run::Runtime, items::Vector{Queryable}, predicate::Function)::Union{Float64, Tuple{Float64, Float64}}</code></pre><p>Return the probability that <code>items</code> satisfy <code>query</code> or lower and upper probabilities.</p><p><code>predicate</code> is a function from Vector{Any} to <code>Bool</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/charles-river-analytics/Scruff.jl/blob/c3a25875ec56c4d160a78e446e7507615fe40666/src/algorithms/query.jl#L130-L136">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Scruff.Algorithms.probability-Tuple{Scruff.Algorithms.Particles, Function}" href="#Scruff.Algorithms.probability-Tuple{Scruff.Algorithms.Particles, Function}"><code>Scruff.Algorithms.probability</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">probability(parts::Particles, predicate::Sample -&gt; Bool)::Float64

Returns the probability that the predicate is satisfied</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/charles-river-analytics/Scruff.jl/blob/c3a25875ec56c4d160a78e446e7507615fe40666/src/algorithms/sample_utils.jl#L29-L33">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Scruff.Algorithms.probability-Union{Tuple{O}, Tuple{Scruff.Algorithms.Algorithm, Runtime, Union{Variable{I, J, O}, VariableInstance{O}} where {I, J}, O}} where O" href="#Scruff.Algorithms.probability-Union{Tuple{O}, Tuple{Scruff.Algorithms.Algorithm, Runtime, Union{Variable{I, J, O}, VariableInstance{O}} where {I, J}, O}} where O"><code>Scruff.Algorithms.probability</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">probability(alg::Algorithm, run::Runtime, item::Queryable{O}, value::O)::Union{Float64, Tuple{Float64, Float64}} where O</code></pre><p>Return the probability that <code>item</code> has <code>value</code> or lower and upper probabilities.</p><p>The default implementation tries to use the more general probability of a query. If that fails, it uses the <code>cpdf</code> operation on the marginal of <code>item</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/charles-river-analytics/Scruff.jl/blob/c3a25875ec56c4d160a78e446e7507615fe40666/src/algorithms/query.jl#L147-L154">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Scruff.Algorithms.probability_bounds-Tuple{Scruff.Algorithms.Algorithm, Runtime, Union{Variable{I, J, O}, VariableInstance{O}} where {O, I, J}, Vector}" href="#Scruff.Algorithms.probability_bounds-Tuple{Scruff.Algorithms.Algorithm, Runtime, Union{Variable{I, J, O}, VariableInstance{O}} where {O, I, J}, Vector}"><code>Scruff.Algorithms.probability_bounds</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">probability_bounds(alg::Algorithm, run::Runtime, item::Queryable, range::Vector)::Tuple{Vector{Float64}, Vector{Float64}}

For an algorithm that produces lower and upper bounds, return vectors of lower and upper bounds on probabilities for values in the range.

The range is important for computing the bounds, because it is assumed that values outside the range have probability zero.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/charles-river-analytics/Scruff.jl/blob/c3a25875ec56c4d160a78e446e7507615fe40666/src/algorithms/query.jl#L189-L195">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Scruff.Algorithms.refine-Tuple{Scruff.Algorithms.IterativeAlgorithm, InstantRuntime}" href="#Scruff.Algorithms.refine-Tuple{Scruff.Algorithms.IterativeAlgorithm, InstantRuntime}"><code>Scruff.Algorithms.refine</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">refine(algorithm::IterativeAlgorithm, runtime::InstantRuntime)</code></pre><p>Perform the next iteration of the algorithm.</p><p>Uses the algorithm state stored in <code>runtime</code> and stores the next state in <code>runtime</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/charles-river-analytics/Scruff.jl/blob/c3a25875ec56c4d160a78e446e7507615fe40666/src/algorithms/iterative/iterativealgorithm.jl#L40-L46">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Scruff.Algorithms.rejection_proposal-Tuple{Runtime, VariableInstance}" href="#Scruff.Algorithms.rejection_proposal-Tuple{Runtime, VariableInstance}"><code>Scruff.Algorithms.rejection_proposal</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">rejection_proposal(::Runtime, instance::VariableInstance, parent_values::Tuple)</code></pre><p>Return a proposer and scorer to implement standard rejection sampling from the prior. It proposes a value for the <code>instance</code> from its sfunc, and scores it by the evidence, if any. If the score is -Infinity, it throws a Reject exception.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/charles-river-analytics/Scruff.jl/blob/c3a25875ec56c4d160a78e446e7507615fe40666/src/algorithms/instant/importance.jl#L65-L71">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Scruff.Algorithms.retrieve_values_from_instant_runtime!-Union{Tuple{T}, Tuple{DynamicRuntime{T}, InstantRuntime}} where T" href="#Scruff.Algorithms.retrieve_values_from_instant_runtime!-Union{Tuple{T}, Tuple{DynamicRuntime{T}, InstantRuntime}} where T"><code>Scruff.Algorithms.retrieve_values_from_instant_runtime!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">retrieve_values_from_instant_runtime!(dynrun::DynamicRuntime, instrun::InstantRuntime)

Retrieve values in a dynamic runtime from an instant runtime constructed
using `instant_runtime_from_instances`.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/charles-river-analytics/Scruff.jl/blob/c3a25875ec56c4d160a78e446e7507615fe40666/src/algorithms/filtering/windowutils.jl#L162-L167">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Scruff.Algorithms.variance-Tuple{Scruff.Algorithms.Algorithm, Runtime, Union{Variable{I, J, O}, VariableInstance{O}} where {O, I, J}}" href="#Scruff.Algorithms.variance-Tuple{Scruff.Algorithms.Algorithm, Runtime, Union{Variable{I, J, O}, VariableInstance{O}} where {O, I, J}}"><code>Scruff.Algorithms.variance</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">variance(alg::Algorithm, runtime::Runtime, item::Queryable)::Float64</code></pre><p>Return the variance of <code>item</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/charles-river-analytics/Scruff.jl/blob/c3a25875ec56c4d160a78e446e7507615fe40666/src/algorithms/query.jl#L258-L262">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../models/">« Models</a><a class="docs-footer-nextpage" href="../utilities/">Utilities »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Friday 10 February 2023 17:30">Friday 10 February 2023</span>. Using Julia version 1.7.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
